<?xml version="1.0" encoding="utf-8"?>
<resources>

    <string name="app_name">DebugPractice</string>
    <string name="action_settings">Settings</string>
    <string name="hello_world">これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。文章は、長くなればなるほど計算に必要な時間が増えます。つまり、長い文章ほどレイアウトに時間がかかるようになります。このように長い文章になると、端末によっては、計算が追いつかずにほとんどフリーズしているように見えるものもあります。特に、Galaxy シリーズは注意が必要です。あまりに長文を割り当ててしまうと、スクロールビューで 1px スクロールするたびに計算が走るため、ほとんど操作ができなくなります。この実習では、どのメソッドに時間がかかっているかを調べて頂きます。スクロールするたび、どのメソッドが呼ばれているかをプロファイラで観察し、時間がかかっていると思われるメソッドの名前をレポートしてください。プロファイラはデバッグをする上でとても重要なツールです。推測ではなく、測定せよ、との言葉がありますが、プロファイラを始めとして、様々な測定ツールが、SDK で提供されています。どれも、アプリの品質向上には欠かせないものばかりです。この実習では、メソッドの実行時間を調べるための、スレッドのプロファイラの使い方を学びますが、この他、もう 1 つ重要なプロファイラツールとして、Memory Analyzer Tool があります。これは、一般的な Java のヒープダンプから、メモリリークの可能性を探るためのツールです。Android にも適用することができ、SDK で提供されている、ヒープダンプ出力ツールから、HPROF ファイルを受け取って、メモリリークの可能性を探ることができます。Android では、Context のライフサイクルを考慮に入れた設計が求められます。これを怠ると、容易にメモリリークを起こし、操作に対する反応が鈍くなったり、計算に時間がかかったり、最悪、OutOfMemoryError でアプリがクラッシュしてしまいます。OutOfMemoryError は、Android アプリを運用していく上で最もよく現れるバグレポートの 1 つです。Context のライフサイクルを超えてオブジェクトが生き続けていることの他にも、Bitmap オブジェクトをメモリに乗せている場合にも起こり得ます。Android 2.3 までの端末では、Bitmap オブジェクトは、オブジェクトそのものはヒープに保存されますが、ピクセルデータはヒープ領域とは別の領域に保存されます。Android 3.0 以上の端末では、オブジェクトそのものも、ピクセルデータも両方ヒープ領域に保存されます。これはとても重要なメモリ管理上の問題を引き起こします。Android 2.3 以前では、ヒープ領域とは別の場所に保存するため、Dalvik VM のガーベジコレクションの対象となりません。つまり、明示的にそのビットマップデータを利用しないことをシステムに教えない限り、メモリ上にデータが乗り続けます。この状態でビットマップデータをどんどん利用していくと、メモリに収まるデータ量を容易に超えて、OutOfMemoryError となってしまいます。また、ビットマップのピクセルデータはとても膨大な情報量を持っています。効率的にメモリ空間を使用するために、ビットマップデータは、必要な階調で取得するよう最適化しておくことが強く勧められます。このようにすることで、無駄なメモリ消費が抑えられます。Bitmap は Parcelable インタフェースを実装しています。しかし、殆どの場合において、Bitmap を Bundle や Intent に詰めることは推奨されていません。レイアウトの話に戻ると、テキスト以外にも、メモリ管理やパフォーマンスの観点から、避けるべき項目がいくつかあります。ひとつには、LinearLayout の layout_weight の使用についてです。ネストした layout_weight はその分だけ計算のコストが掛かります。出来る限り、RelativeLayout で構築することを推奨します。ふたつには、レイアウトのネストの深さにも注意を払う必要があります。ネストするということは、それだけ木構造が深くなるということです。レイアウトは、その木構造を再帰的に辿って処理を実行していきます。このため、木構造があまりにも深くなりすぎると、スタック領域に収まりきらなくなり、StackOverFlowError が起こります。無駄なレイアウト階層は作らないよう心がける事と同時に、ひとつの画面で多くの情報を見せ過ぎないことも重要です。また、TextView のように、View の内部でレイアウトを持っているものもありますので、注意してください。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。通常、このように長い文章を、リソースとして定義することはないでしょう。しかし、ブログや日記のような、長文を表示するためのアプリでは、外部のデータソースから、このように長い文章が渡ってくる可能性があります。標準では、絵文字には対応していませんが、独自に拡張して絵文字対応などを行った場合には、さらなる注意が必要となります。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。もちろんですが、レイアウト以外に、UI スレッドで時間のかかる処理をしてはいけません。また、UI スレッドとは別のスレッドでバックグラウンド処理をする場合、ユーザに対して、処理中であることを通知する表示を行うべきです。何故ならば、その間ユーザは待たなければならず、処理中である表示がないと一体なんのために待っているかがわからないためです。このような表示は、一般的には、ProgressDialog が用いられます。あるいは、ブラウザのような読み込みを行うものであれば、プログレスバーを表示するのもひとつの選択肢です。何れにしても、なぜ待たなければならないのか、その納得のいく説明をユーザに提示する必要が最低限求められています。その処理が終わったならば、終わった旨、Toast や Notification などを用いて通知を表示しましょう。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。これはとても長い文章です。</string>

</resources>
